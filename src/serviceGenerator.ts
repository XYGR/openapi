import consola from "consola";
import { readFileSync } from "fs";
import glob from "glob";
import * as nunjucks from "nunjucks";
import type { ContentObject, OpenAPIObject, OperationObject, ParameterObject, PathItemObject, ReferenceObject, RequestBodyObject, ResponseObject, ResponsesObject, SchemaObject } from "openapi3-ts";
import { join } from "path";
import ReservedDict from "reserved-words";
import rimraf from "rimraf";
import pinyin from "tiny-pinyin";
import type { GenerateServiceProps } from "./index";
import { writeFile } from "./util";

export interface APIDataType extends OperationObject {
	path: string;
	method: string;
}
  
export type TagAPIDataType = Record<string, APIDataType[]>;

export interface ControllerType {
  fileName: string;
  controllerName: string;
}

export interface MappingItemType {
  antTechApi: string;
  popAction: string;
  popProduct: string;
  antTechVersion: string;
}

export type TypescriptFileType = "interface" | "serviceController" | "serviceIndex";

const DEFAULT_SCHEMA: SchemaObject = {
  type: "object",
  properties: { id: { type: "number", }, },
};

const DEFAULT_PATH_PARAM: ParameterObject = {
  in: "path",
  name: null,
  schema: {
    type: "string",
  },
  required: true,
  isObject: false,
  type: "string",
};

class ServiceGenerator {
  protected apiData: TagAPIDataType = {};
  
  protected classNameList: ControllerType[] = [];
  
  protected version: string;
  
  protected mappings: MappingItemType[] = [];
  
  protected finalPath: string;
  
  protected config: GenerateServiceProps;
  protected openAPIData: OpenAPIObject;
  
  // ÊûÑÈÄ†ÊñπÊ≥ï ÂàùÂßãÂåñÈÄªËæë
  constructor(config: GenerateServiceProps, openAPIData: OpenAPIObject) {
    this.finalPath = "";
    this.config = {
      projectName: "api",
      serversPath: "./src/service",
      templatesFolder: join(__dirname, "../", "templates"),   // Ê®°ÁâàÊñá‰ª∂Â§πË∑ØÂæÑ
      ...config, // ‰ΩøÁî®ÂØπË±°Â±ïÂºÄËøêÁÆóÁ¨¶ÔºåÂ∞Ü‰º†ÂÖ•ÁöÑ config ÂèÇÊï∞ÂêàÂπ∂Âà∞ÈªòËÆ§ÈÖçÁΩÆ‰∏≠
    };
    this.openAPIData = openAPIData; // ÂÆû‰æãÂ±ûÊÄßÔºå‰øùÂ≠ò‰ªé OpenAPI ËßÑËåÉ‰∏≠Ëß£ÊûêÂæóÂà∞ÁöÑÊï∞ÊçÆ
    const { info, } = openAPIData; // Ëé∑Âèñ OpenAPI ËßÑËåÉ‰∏≠ÁöÑ info Â±ûÊÄß
    const basePath = ""; // Âü∫Á°ÄË∑ØÂæÑÔºåÊöÇÊó∂‰∏∫Á©∫Â≠óÁ¨¶‰∏≤
    this.version = info.version; // ÂÆû‰æãÂ±ûÊÄßÔºå‰øùÂ≠ò OpenAPI ËßÑËåÉ‰∏≠ÁöÑÁâàÊú¨Âè∑‰ø°ÊÅØ

    // ÈÅçÂéÜ paths ÂØπË±°ÔºåÂ∞ÜÊØè‰∏™ HTTP ÊñπÊ≥ïÁöÑ API ÂÆö‰πâÊ∑ªÂä†Âà∞ÂÆû‰æãÁöÑ apiData Â±ûÊÄß‰∏≠
    Object.keys(openAPIData.paths || {}).forEach((p) => {
      const pathItem: PathItemObject = openAPIData.paths[p]; // Ëé∑ÂèñÂΩìÂâçË∑ØÂæÑÁöÑ PathItemObject ÂØπË±°
      ["get", "put", "post", "delete", "patch"].forEach((method) => {
        const operationObject: OperationObject = pathItem[method]; // Ëé∑ÂèñÂΩìÂâç HTTP ÊñπÊ≥ïÁöÑ OperationObject ÂØπË±°
        if (!operationObject) { // Â¶ÇÊûú‰∏çÂ≠òÂú®ÔºåÂàôÈÄÄÂá∫Êú¨Ê¨°Âæ™ÁéØ
          return;
        }
        // ÂÆö‰πâÊñá‰ª∂ÂêçÁß∞
        const fileNmae = `${p.split("/")[1]}Controller`
        // ÈÅçÂéÜÊ†áÁ≠æÊï∞ÁªÑÔºåÂ∞ÜÂΩìÂâçÊìç‰ΩúÊ∑ªÂä†Âà∞Áõ∏Â∫îÁöÑÁ±ªÂûãÂêçÁß∞‰∏ã
        if (!this.apiData[fileNmae]) { // Â¶ÇÊûúÂΩìÂâçÁ±ªÂûãËøò‰∏çÂ≠òÂú®ÔºåÂàôÂàõÂª∫‰∏Ä‰∏™Á©∫Êï∞ÁªÑ
          this.apiData[fileNmae] = [];
        }
        // Â∞ÜÂΩìÂâçÊìç‰ΩúÊ∑ªÂä†Âà∞ÂØπÂ∫îÁöÑÁ±ªÂûãÂêçÁß∞‰∏ã
        this.apiData[fileNmae].push({
          path: `${basePath}${p}`, // ËÆ°ÁÆóÂÆåÊï¥ÁöÑË∑ØÂæÑ‰ø°ÊÅØ
          method,
          ...operationObject, // ÂêàÂπ∂ OperationObject ÂØπË±°‰∏≠ÁöÑÂÖ∂‰ªñÂ±ûÊÄß
        });
      });
    });
  }
  

  public genFile() {
    const basePath = this.config.serversPath;
    try {
      // ÊãºÊé•ÂÆåÊï¥Ë∑ØÂæÑ
      const finalPath = join(basePath, this.config.projectName);
  
      this.finalPath = finalPath;
      // Êü•ÊâæÂπ∂Âà†Èô§ÁõÆÂΩï‰∏ãÊâÄÊúâÊñá‰ª∂
      glob
        .globSync(`${finalPath}/**/*`)
        .filter((ele) => !ele.includes("_deperated"))
        .forEach((ele) => {
          rimraf.sync(ele);
        });
    } catch (error) {
      consola.error(`üö• serves ÁîüÊàêÂ§±Ë¥•: ${error}`)
    }
  
    // ÁîüÊàê ts Á±ªÂûãÂ£∞Êòé typings.d.ts Êñá‰ª∂ Ê®°ÁâàÊòØ interface.njk
    this.genFileFromTemplate("typings.d.ts", "interface", {
      namespace: this.config.namespace,
      nullable: this.config.nullable,
      list: this.getInterfaceTP(),
      disableTypeCheck: false,
    });
    // ÁîüÊàê controller Êñá‰ª∂
    const prettierError = [];
    // ÁîüÊàê service ÁªüËÆ°
    this.getServiceTP().forEach((tp) => {
      // Ê†πÊçÆÂΩìÂâçÊï∞ÊçÆÊ∫êÁ±ªÂûãÈÄâÊã©ÊÅ∞ÂΩìÁöÑ controller Ê®°Áâà
      const template = "serviceController";
      const hasError = this.genFileFromTemplate(
        this.getFinalFileName(`${tp.className}.ts`),
        template,
        {
          namespace: this.config.namespace,
          requestImportStatement: this.config.requestImportStatement,
          disableTypeCheck: false,
          ...tp,
        }
      );
      prettierError.push(hasError);
    });
    
    if (prettierError.includes(true)) {
      consola.error("üö• Ê†ºÂºèÂåñÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü• service Êñá‰ª∂ÂÜÖÂèØËÉΩÂ≠òÂú®ÁöÑËØ≠Ê≥ïÈîôËØØ");
    }
    // ÁîüÊàê index Êñá‰ª∂
    this.genFileFromTemplate("index.ts", "serviceIndex", {
      list: this.classNameList,
      disableTypeCheck: false,
    });
  
    // ÊâìÂç∞Êó•Âøó
    consola.info("‚úÖ ÊàêÂäüÁîüÊàê service Êñá‰ª∂");
  }
  
  public concatOrNull = (...arrays) => {
    const c = [].concat(...arrays.filter(Array.isArray));
    return c.length > 0 ? c : null;
  };
  
  /**
   * @description Ëé∑ÂèñAPIÊñπÊ≥ïÂêçÁß∞
   * @param data dataÂØπË±°
   * @return String ÊñπÊ≥ïÂêçÁß∞
  */
  public getFuncationName(data: APIDataType) {
    let apiPrefix = ""
    if (this.config.apiPrefix && typeof this.config.apiPrefix === "string") {
      apiPrefix = this.config.apiPrefix.replace(/\'/g,"")
    }
    return this.config.hook && this.config.hook.customFunctionName
      ? this.config.hook.customFunctionName(data)
      :this.pathToHump(apiPrefix + data.path)
  }
  
  public getTypeName(data: APIDataType) {
    // ÂëΩÂêçÁ©∫Èó¥ÂêçÁß∞
    const namespace = this.config.namespace ? `${this.config.namespace}.` : "";
    // ÊñπÊ≥ïÂêçÁß∞
    let typeName = this.config?.hook?.customTypeName?.(data)
        || this.pathToHump(data.path);
    // ËΩ¨Â§ßÈ©ºÂ≥∞ÂëΩÂêç
    typeName = typeName.slice(0,1).toUpperCase() + typeName.slice(1)
    // ÊñπÊ≥ïÂêçÊãºÊé• `Params` Âπ∂ÂéªÈáç
    return resolveTypeName(`${namespace}${typeName ?? data.operationId}Params`);
  }
  
  public getServiceTP() {
    return Object.keys(this.apiData)
      .map((tag) => {
        // functionName tag Á∫ßÂà´Èò≤Èáç
        const tmpFunctionRD: Record<string, number> = {};
        const genParams = this.apiData[tag]
          .filter(
            (api) =>
            // ÊöÇ‰∏çÊîØÊåÅÂèòÈáè
              !api.path.includes("${")
          )
          .map((api) => {
            const newApi = api;
            try {
              const allParams = this.getParamsTP(newApi.parameters, newApi.path);
              const body = this.getBodyTP(newApi.requestBody);
              const response = this.getResponseTP(newApi.responses);
  
              // let { file, ...params } = allParams || {}; // I dont't know if 'file' is valid parameter, maybe it's safe to remove it
              // const newfile = this.getFileTP(newApi.requestBody);
              // file = this.concatOrNull(file, newfile);
              const params = allParams || {};
              const file = this.getFileTP(newApi.requestBody);
  
              let formData = false;
              if ((body && (body.mediaType || "").includes("form")) || file) {
                formData = true;
              }
  
              let functionName = this.getFuncationName(newApi);
  
              if (functionName && tmpFunctionRD[functionName]) {
                functionName = `${functionName}_${(tmpFunctionRD[functionName] += 1)}`;
              } else if (functionName) {
                tmpFunctionRD[functionName] = 1;
              }
  
              let formattedPath = newApi.path.replace(
                /:([^/]*)|{([^}]*)}/gi,
                (_, str, str2) => `$\{${str || str2}}`
              );
              if (newApi.extensions && newApi.extensions["x-antTech-description"]) {
                const { extensions, } = newApi;
                const { apiName, antTechVersion, productCode, antTechApiName, } =
                    extensions["x-antTech-description"];
                formattedPath = antTechApiName || formattedPath;
                this.mappings.push({
                  antTechApi: formattedPath,
                  popAction: apiName,
                  popProduct: productCode,
                  antTechVersion,
                });
                newApi.antTechVersion = antTechVersion;
              }
  
              // ‰∏∫ path ‰∏≠ÁöÑ params Ê∑ªÂä† alias
              const escapedPathParams = ((params || {}).path || []).map((ele, index) => ({
                ...ele,
                alias: `param${index}`,
              }));
              if (escapedPathParams.length) {
                escapedPathParams.forEach((param) => {
                  formattedPath = formattedPath.replace(`$\{${param.name}}`, `$\{${param.alias}}`);
                });
              }
  
              const finalParams =
                  escapedPathParams && escapedPathParams.length
                    ? { ...params, path: escapedPathParams, }
                    : params;
  
              // Â§ÑÁêÜ query ‰∏≠ÁöÑÂ§çÊùÇÂØπË±°
              if (finalParams && finalParams.query) {
                finalParams.query = finalParams.query.map((ele) => ({
                  ...ele,
                  isComplexType: ele.isObject,
                }));
              }
  
              const getPrefixPath = () => {
                if (!this.config.apiPrefix) {
                  return formattedPath;
                }
                // ÈùôÊÄÅ apiPrefix
                const prefix =
                    typeof this.config.apiPrefix === "function"
                      ? `${this.config.apiPrefix({
                        path: formattedPath,
                        method: newApi.method,
                        namespace: tag,
                        functionName,
                      })}`.trim()
                      : this.config.apiPrefix.trim();
  
                if (!prefix) {
                  return formattedPath;
                }
  
                if (prefix.startsWith("'") || prefix.startsWith("\"") || prefix.startsWith("`")) {
                  const finalPrefix = prefix.slice(1, prefix.length - 1);
                  if (
                    formattedPath.startsWith(finalPrefix) ||
                      formattedPath.startsWith(`/${finalPrefix}`)
                  ) {
                    return formattedPath;
                  }
                  return `${finalPrefix}${formattedPath}`;
                }
                // prefix ÂèòÈáè
                return `$\{${prefix}}${formattedPath}`;
              };
  
              return {
                ...newApi,
                functionName,
                typeName: this.getTypeName(newApi),
                path: getPrefixPath(),
                pathInComment: formattedPath.replace(/\*/g, "&#42;"),
                hasPathVariables: formattedPath.includes("{"),
                hasApiPrefix: !!this.config.apiPrefix,
                method: newApi.method,
                // Â¶ÇÊûú functionName Âíå summary Áõ∏ÂêåÔºåÂàô‰∏çÊòæÁ§∫ summary
                desc:
                    functionName === newApi.summary
                      ? newApi.description
                      : [newApi.summary, newApi.description].filter((s) => s).join(" "),
                hasHeader: !!(params && params.header) || !!(body && body.mediaType),
                params: finalParams,
                hasParams: Boolean(Object.keys(finalParams || {}).length),
                body,
                file,
                hasFormData: formData,
                response,
              };
            } catch (error) {
              // eslint-disable-next-line no-console
              console.error("[GenSDK] gen service param error:", error);
              throw error;
            }
          })
        // ÊéíÂ∫è‰∏ãÔºåË¶Å‰∏çÊØèÊ¨°gitÈÉΩ‰π±‰∫Ü
          .sort((a, b) => a.path.localeCompare(b.path));
  
        const fileName = this.replaceDot(tag);
  
        let className = fileName;
        if (this.config.hook && this.config.hook.customClassName) {
          className = this.config.hook.customClassName(tag);
        }
        if (genParams.length) {
          this.classNameList.push({
            fileName: className,
            controllerName: className,
          });
        }
        return {
          genType: "ts",
          className,
          instanceName: `${fileName[0].toLowerCase()}${fileName.substr(1)}`,
          list: genParams,
        };
      })
      .filter((ele) => !!ele.list.length);
  }
  
  public getBodyTP(requestBody: any = {}) {
    const reqBody: RequestBodyObject = this.resolveRefObject(requestBody);
    if (!reqBody) {
      return null;
    }
    const reqContent: ContentObject = reqBody.content;
    if (typeof reqContent !== "object") {
      return null;
    }
    let mediaType = Object.keys(reqContent)[0];
  
    const schema: SchemaObject = reqContent[mediaType].schema || DEFAULT_SCHEMA;
  
    if (mediaType === "*/*") {
      mediaType = "";
    }
    // Â¶ÇÊûú requestBody Êúâ required Â±ûÊÄßÔºåÂàôÊ≠£Â∏∏Â±ïÁ§∫ÔºõÂ¶ÇÊûúÊ≤°ÊúâÔºåÈªòËÆ§ÈùûÂøÖÂ°´
    const required = typeof requestBody.required === "boolean" ? requestBody.required : false;
    if (schema.type === "object" && schema.properties) {
      const propertiesList = Object.keys(schema.properties).map((p) => {
        if (schema.properties && schema.properties[p] && !["binary", "base64"].includes((schema.properties[p] as SchemaObject).format || "") && !(["string[]", "array"].includes((schema.properties[p] as SchemaObject).type || "") && ["binary", "base64"].includes(((schema.properties[p] as SchemaObject).items as SchemaObject).format || ""))) {
          return {
            key: p,
            schema: {
              ...schema.properties[p],
              type: getType(schema.properties[p], this.config.namespace),
              required: schema.required?.includes(p) ?? false,
            },
          };
        }
        return undefined;
      }).filter(p => p);
      return {
        mediaType,
        ...schema,
        required,
        propertiesList,
      };
    }
    return {
      mediaType,
      required,
      type: getType(schema, this.config.namespace),
    };
  }
  public getFileTP(requestBody: any = {}) {
    const reqBody: RequestBodyObject = this.resolveRefObject(requestBody);
    if (reqBody && reqBody.content && reqBody.content["multipart/form-data"]) {
      const ret = this.resolveFileTP(reqBody.content["multipart/form-data"].schema);
      return ret.length > 0 ? ret : null;
    }
    return null;
  }
  public resolveFileTP(obj: any) {
    let ret = [];
    const resolved = this.resolveObject(obj);
    const props =
        (resolved.props && resolved.props.length > 0 &&
          resolved.props[0].filter((p) => p.format === "binary" || p.format === "base64" || ((p.type === "string[]" || p.type === "array") && (p.items.format === "binary" || p.items.format === "base64")))) ||
        [];
    if (props.length > 0) {
      ret = props.map((p) => {
        return { title: p.name, multiple: (p.type === "string[]" || p.type === "array"), };
      });
    }
    if (resolved.type) ret = [...ret, ...this.resolveFileTP(resolved.type)];
    return ret;
  }
  
  public getResponseTP(responses: ResponsesObject = {}) {
    const { components, } = this.openAPIData;
    const response: ResponseObject | undefined =
        responses && this.resolveRefObject(responses.default || responses["200"] || responses["201"]);
    const defaultResponse = {
      mediaType: "*/*",
      type: "any",
    };
    if (!response) {
      return defaultResponse;
    }
    const resContent: ContentObject | undefined = response.content;
    const mediaType = Object.keys(resContent || {})[0];
    if (typeof resContent !== "object" || !mediaType) {
      return defaultResponse;
    }
    let schema = (resContent[mediaType].schema || DEFAULT_SCHEMA) as SchemaObject;
  
    if (schema.$ref) {
      const refPaths = schema.$ref.split("/");
      const refName = refPaths[refPaths.length - 1];
      const childrenSchema = components.schemas[refName] as SchemaObject;
      if (childrenSchema?.type === "object" && "properties" in childrenSchema && this.config.dataFields) {
        schema = this.config.dataFields.map(field => childrenSchema.properties[field]).filter(Boolean)?.[0] || resContent[mediaType].schema || DEFAULT_SCHEMA;
      }
    }
      
    if ("properties" in schema) {
      Object.keys(schema.properties).map((fieldName) => {
        // eslint-disable-next-line @typescript-eslint/dot-notation
        schema.properties[fieldName]["required"] = schema.required?.includes(fieldName) ?? false;
      });
    }
    return {
      mediaType,
      type: getType(schema, this.config.namespace),
    };
  }
  
  public getParamsTP(
    parameters: (ParameterObject | ReferenceObject)[] = [],
    path: string = null
  ): Record<string, ParameterObject[]> {
    const templateParams: Record<string, ParameterObject[]> = {};
  
    if (parameters && parameters.length) {
      ["query", "path", "cookie"/* , 'file' */].forEach((source) => {
        // Possible values are "query", "header", "path" or "cookie". (https://swagger.io/specification/)
        const params = parameters
          .map((p) => this.resolveRefObject(p))
          .filter((p: ParameterObject) => p.in === source)
          .map((p) => {
            const isDirectObject = ((p.schema || {}).type || p.type) === "object";
            const refList = ((p.schema || {}).$ref || p.$ref || "").split("/");
            const ref = refList[refList.length - 1];
            const deRefObj = (Object.entries(this.openAPIData.components && this.openAPIData.components.schemas || {}).find(
              ([k]) => k === ref
            ) || []) as any;
            const isRefObject = (deRefObj[1] || {}).type === "object";
            return {
              ...p,
              isObject: isDirectObject || isRefObject,
              type: getType(p.schema || DEFAULT_SCHEMA, this.config.namespace),
            };
          });
  
        if (params.length) {
          templateParams[source] = params;
        }
      });
    }
  
    if (path && path.length > 0) {
      const regex = /\{(\w+)\}/g;
      templateParams.path = templateParams.path || [];
      let match = null;
      while ((match = regex.exec(path))) {
        if (!templateParams.path.some((p) => p.name === match[1])) {
          templateParams.path.push({
            ...DEFAULT_PATH_PARAM,
            name: match[1],
          });
        }
      }
  
      // Â¶ÇÊûú path Ê≤°ÊúâÂÜÖÂÆπÔºåÂàôÂ∞ÜÂà†Èô§ path ÂèÇÊï∞ÔºåÈÅøÂÖçÂΩ±ÂìçÂêéÁª≠ÁöÑ hasParams Âà§Êñ≠
      if (!templateParams.path.length) delete templateParams.path;
    }
  
    return templateParams;
  }
  
  /**
   * @description Ëé∑ÂèñÊé•Âè£ÂèÇÊï∞ÂíåËøîÂõûÁ±ªÂûã
   * @returns Array Á±ªÂûãÊï∞ÁªÑ
  */
  public getInterfaceTP() {
    const { components, } = this.openAPIData;
    
    let data = []
    if (components && components.schemas) {
      // ÈÅçÂéÜ schemas
      data = Object.keys(components.schemas).map((typeName) => {
        const result = this.resolveObject(components.schemas[typeName]);
        
        const getDefinesType = () => {
          if (result.type) {
            return (components.schemas[typeName] as SchemaObject).type === "object" || result.type;
          }
          return "Record<string, any>";
        };
        return {
          typeName: resolveTypeName(typeName),
          type: getDefinesType(),
          parent: result.parent,
          props: result.props || [],
          isEnum: result.isEnum,
        };
      });
    }
  
    // Âº∫Ë°åÊõøÊç¢ÊéâËØ∑Ê±ÇÂèÇÊï∞paramsÁöÑÁ±ªÂûãÔºåÁîüÊàêÊñπÊ≥ïÂØπÂ∫îÁöÑ xxxxParams Á±ªÂûã
    Object.keys(this.openAPIData.paths || {}).forEach((p) => {
      
      const pathItem: PathItemObject = this.openAPIData.paths[p];
      ["get", "put", "post", "delete", "patch"].forEach((method) => {
        // Âà§Êñ≠ËØ∑Ê±ÇÁ±ªÂûã `method`
        const operationObject: OperationObject = pathItem[method];
        // ‰∏çÂåπÈÖçÁöÑÁ±ªÂûãÁõ¥Êé•return
        if (!operationObject) {
          return;
        }
  
        const props = [];
        
        // Âà§Êñ≠ÊòØÂê¶Êúâ `params` ÂèÇÊï∞
        if (operationObject.parameters) {
          // ÈÅçÂéÜ parameters 
          operationObject.parameters.forEach((parameter: any) => {
            // Ê∑ªÂä† porps Â±ûÊÄß
            props.push({
              desc: parameter.description ?? "",
              name: parameter.name,
              required: parameter.required,
              type: getType(parameter.schema),
            });
          }); 
        }
       
        // parameters may be in path
        if (pathItem.parameters) {
          // Ê∑ªÂä† porps Â±ûÊÄß
          pathItem.parameters.forEach((parameter: any) => {
            props.push({
              desc: parameter.description ?? "",
              name: parameter.name,
              required: parameter.required,
              type: getType(parameter.schema),
            });
          });
        }
        // props ‰∏ç‰∏∫Á©∫ Âç≥ Â≠òÂú® params ÂèÇÊï∞
        if (props.length > 0 && data) {
          const typeName = this.pathToHump(p) + "Params"
          data.push([
            {
              typeName: typeName.slice(0,1).toUpperCase() + typeName.slice(1),
              type: "Record<string, any>",
              parent: undefined,
              props: [props],
              isEnum: false,
            }
          ]);
        }
      });
    });
    // ---- ÁîüÊàê xxxparams Á±ªÂûã end---------
    return data && data.reduce((p, c) => p && c && p.concat(c), [])
    // ÊéíÂ∫è‰∏ãÔºåË¶Å‰∏çÊØèÊ¨°gitÈÉΩ‰π±‰∫Ü
      .sort((a, b) => a.typeName.localeCompare(b.typeName));
  }
  
  private genFileFromTemplate(
    fileName: string,
    type: TypescriptFileType,
    params: Record<string, any>
  ): boolean {
    try {
      const template = this.getTemplate(type);
      // ËÆæÁΩÆËæìÂá∫‰∏çËΩ¨‰πâ
      nunjucks.configure({
        autoescape: false,
      });
      return writeFile(this.finalPath, fileName, nunjucks.renderString(template, params));
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("[GenSDK] file gen fail:", fileName, "type:", type);
      throw error;
    }
  }
  
  private getTemplate(type: "interface" | "serviceController" | "serviceIndex"): string {
    return readFileSync(join(this.config.templatesFolder, `${type}.njk`), "utf8");
  }
  
  // Ëé∑Âèñ TS Á±ªÂûãÁöÑÂ±ûÊÄßÂàóË°®
  getProps(schemaObject: SchemaObject) {
    const requiredPropKeys = schemaObject?.required ?? false;
    return schemaObject.properties
      ? Object.keys(schemaObject.properties).map((propName) => {
        const schema: SchemaObject =
            (schemaObject.properties && schemaObject.properties[propName]) || DEFAULT_SCHEMA;
        return {
          ...schema,
          name: propName,
          type: getType(schema),
          desc: [schema.title, schema.description].filter((s) => s).join(" "),
          // Â¶ÇÊûúÊ≤°Êúâ required ‰ø°ÊÅØÔºåÈªòËÆ§ÂÖ®ÈÉ®ÊòØÈùûÂøÖÂ°´
          required: requiredPropKeys ? requiredPropKeys.some((key) => key === propName) : false,
        };
      })
      : [];
  }
  
  resolveObject(schemaObject: SchemaObject) {
    // ÂºïÁî®Á±ªÂûã
    if (schemaObject.$ref) {
      return this.resolveRefObject(schemaObject);
    }
    // Êûö‰∏æÁ±ªÂûã
    if (schemaObject.enum) {
      return this.resolveEnumObject(schemaObject);
    }
    // ÁªßÊâøÁ±ªÂûã
    if (schemaObject.allOf && schemaObject.allOf.length) {
      return this.resolveAllOfObject(schemaObject);
    }
    // ÂØπË±°Á±ªÂûã
    if (schemaObject.properties) {
      return this.resolveProperties(schemaObject);
    }
    // Êï∞ÁªÑÁ±ªÂûã
    if (schemaObject.items && schemaObject.type === "array") {
      return this.resolveArray(schemaObject);
    }
    return schemaObject;
  }
  
  resolveArray(schemaObject: SchemaObject) {
    if (schemaObject.items.$ref) {
      const refObj = schemaObject.items.$ref.split("/");
      return {
        type: `${refObj[refObj.length - 1]}[]`,
      };
    }
    // TODO: ËøôÈáåÈúÄË¶ÅËß£ÊûêÂá∫ÂÖ∑‰ΩìÂ±ûÊÄßÔºå‰ΩÜÁî±‰∫é parser Â±ÇËøò‰∏çÁ°ÆÂÆöÔºåÊâÄ‰ª•ÊöÇÊó∂ÂÖàËøîÂõû any
    return "any[]";
  }
  
  resolveProperties(schemaObject: SchemaObject) {
    return {
      props: [this.getProps(schemaObject)],
    };
  }
  
  resolveEnumObject(schemaObject: SchemaObject) {
    const enumArray = schemaObject.enum;
  
    let enumStr;
    switch (this.config.enumStyle) {
    case "enum":
      enumStr = `{${enumArray.map((v) => `${v}="${v}"`).join(",")}}`;
      break;
    case "string-literal":
      enumStr = Array.from(
        new Set(
          enumArray.map((v) =>
            typeof v === "string" ? `"${v.replace(/"/g, "\"")}"` : getType(v)
          )
        )
      ).join(" | ");
      break;
    default:
      break;
    }
  
    return {
      isEnum: this.config.enumStyle == "enum",
      type: Array.isArray(enumArray) ? enumStr : "string",
    };
  }
  
  resolveAllOfObject(schemaObject: SchemaObject) {
    const props = (schemaObject.allOf || []).map((item) =>
      item.$ref ? [{ ...item, type: getType(item).split("/").pop(), }] : this.getProps(item)
    );
    return { props, };
  }
  
  // Â∞ÜÂú∞ÂùÄpathË∑ØÂæÑËΩ¨‰∏∫Â∞èÈ©ºÂ≥∞
  private pathToHump(path: string) {
    // ÂÖàÂéªÊéâÁ¨¨‰∏Ä‰∏™/Âπ∂Â∞ÜpathËΩ¨‰∏∫Êï∞ÁªÑ
    // Â∞ÜÊï∞ÁªÑÂÜÖÂ≠óÁ¨¶‰∏≤È¶ñÂ≠óÊØçÂ§ßÂÜôÂπ∂ËΩ¨Âåñ‰∏∫Â≠óÁ¨¶‰∏≤
    return path.slice(1).split("/").map((p,i) => {
      if (i === 0) {
        return p
      }
      return p.slice(0,1).toUpperCase() + p.slice(1)
    }).join("")
  }
  
  private resolveRefObject(refObject: any): any {
    if (!refObject || !refObject.$ref) {
      return refObject;
    }
    const refPaths = refObject.$ref.split("/");
    if (refPaths[0] === "#") {
      refPaths.shift();
      let obj: any = this.openAPIData;
      refPaths.forEach((node: any) => {
        obj = obj[node];
      });
      if (!obj) {
        throw new Error(`[GenSDK] Data Error! Notfoud: ${refObject.$ref}`);
      }
      return {
        ...this.resolveRefObject(obj),
        type: obj.$ref ? this.resolveRefObject(obj).type : obj,
      };
    }
    return refObject;
  }
  
  private getFinalFileName(s: string): string {
    // ÊîØÊåÅ‰∏ãÂàíÁ∫ø„ÄÅ‰∏≠ÂàíÁ∫øÂíåÁ©∫Ê†ºÂàÜÈöîÁ¨¶ÔºåÊ≥®ÊÑèÂàÜÈöîÁ¨¶Êûö‰∏æÂÄºÁöÑÈ°∫Â∫è‰∏çËÉΩÊîπÂèòÔºåÂê¶ÂàôÊ≠£ÂàôÂåπÈÖç‰ºöÊä•Èîô
    return s.replace(/[-_ ](\w)/g, (_all, letter) => letter.toUpperCase());
  }
  
  private replaceDot(s: string) {
    return s.replace(/\./g, "_").replace(/[-_ ](\w)/g, (_all, letter) => letter.toUpperCase());
  }
}

/**
 * @description Á±ªÂûãÂ£∞ÊòéËøáÊª§ÂÖ≥ÈîÆÂ≠ó
 * @param typeName Á±ªÂûãÂêçÁß∞
 * @returns String
*/
const resolveTypeName = (typeName: string) => {
  // Âà§Êñ≠ÊòØÂê¶ÂëΩ‰∏≠‰∫ÜJS‰øùÁïôÁöÑÂÖ≥ÈîÆÂ≠ó
  if (ReservedDict.check(typeName)) {
    return `__openAPI__${typeName}`;
  }
  const name = typeName.split(".").pop().replace(/[^\w^\s^\u4e00-\u9fa5]/gi, "");
  // ÂΩìmodelÂêçÁß∞ÊòØnumberÂºÄÂ§¥ÁöÑÊó∂ÂÄôÔºåts‰ºöÊä•Èîô„ÄÇËøôÁßçÂú∫ÊôØ‰∏ÄËà¨ÂèëÁîüÂú®ÂêéÁ´ØÂÆö‰πâÁöÑÂêçÁß∞ÊòØ‰∏≠Êñá
  if (name === "_" || /^\d+$/.test(name)) {
    consola.warn("‚ö†Ô∏è  models‰∏çËÉΩ‰ª•numberÂºÄÂ§¥ÔºåÂéüÂõ†ÂèØËÉΩÊòØModelÂÆö‰πâÂêçÁß∞‰∏∫‰∏≠Êñá, Âª∫ËÆÆËÅîÁ≥ªÂêéÂè∞‰øÆÊîπ")
    return `Pinyin_${name}`
  }
  if (!/[\u3220-\uFA29]/.test(name) && !/^\d$/.test(name)) {
    return name;
  }
  const noBlankName = name.replace(/ +/g, "")
  return pinyin.convertToPinyin(noBlankName, "", true);
};

/**
 * @description Ëé∑ÂèñÁ±ªÂûãÂ£∞Êòé
 * @param schemaObject JSONÂØπË±°
 * @returns String
*/
const getType = (schemaObject: SchemaObject | undefined, namespace = ""): string => {
  if (schemaObject === undefined || schemaObject === null) {
    return "any";
  }
  if (typeof schemaObject !== "object") {
    return schemaObject;
  }
  if (schemaObject.$ref) {
    return [namespace, getRefName(schemaObject)].filter((s) => s).join(".");
  }

  let { type, } = schemaObject as any;

  const numberEnum = [
    "int64",
    "integer",
    "long",
    "float",
    "double",
    "number",
    "int",
    "float",
    "double",
    "int32",
    "int64"
  ];

  const dateEnum = ["Date", "date", "dateTime", "date-time", "datetime"];

  const stringEnum = ["string", "email", "password", "url", "byte", "binary"];

  if (numberEnum.includes(schemaObject.format)) {
    type = "number";
  }

  if (schemaObject.enum) {
    type = "enum";
  }

  if (numberEnum.includes(type)) {
    return "number";
  }

  if (dateEnum.includes(type)) {
    return "Date";
  }

  if (stringEnum.includes(type)) {
    return "string";
  }

  if (type === "boolean") {
    return "boolean";
  }

  if (type === "array") {
    let { items, } = schemaObject;
    if (schemaObject.schema) {
      items = schemaObject.schema.items;
    }

    if (Array.isArray(items)) {
      const arrayItemType = (items as any)
        .map((subType) => getType(subType.schema || subType, namespace))
        .toString();
      return `[${arrayItemType}]`;
    }
    const arrayType = getType(items, namespace);
    return arrayType.includes(" | ") ? `(${arrayType})[]` : `${arrayType}[]`;
  }

  if (type === "enum") {
    return Array.isArray(schemaObject.enum)
      ? Array.from(
        new Set(
          schemaObject.enum.map((v) =>
            typeof v === "string" ? `"${v.replace(/"/g, "\"")}"` : getType(v)
          )
        )
      ).join(" | ")
      : "string";
  }

  if (schemaObject.oneOf && schemaObject.oneOf.length) {
    return schemaObject.oneOf.map((item) => getType(item, namespace)).join(" | ");
  }
  if (schemaObject.allOf && schemaObject.allOf.length) {
    return `(${schemaObject.allOf.map((item) => getType(item, namespace)).join(" & ")})`;
  }
  if (schemaObject.type === "object" || schemaObject.properties) {
    if (!Object.keys(schemaObject.properties || {}).length) {
      return "Record<string, any>";
    }
    return `{ ${Object.keys(schemaObject.properties)
      .map((key) => {
        const required =
          "required" in (schemaObject.properties[key] || {})
            ? ((schemaObject.properties[key] || {}) as any).required
            : false;
        /** 
         * Â∞ÜÁ±ªÂûãÂ±ûÊÄßÂèò‰∏∫Â≠óÁ¨¶‰∏≤ÔºåÂÖºÂÆπÈîôËØØÊ†ºÂºèÂ¶ÇÔºö
         * 3d_tile(Êï∞Â≠óÂºÄÂ§¥)Á≠âÈîôËØØÂëΩÂêçÔºå
         * Âú®ÂêéÈù¢ËøõË°åÊ†ºÂºèÂåñÁöÑÊó∂ÂÄô‰ºöÂ∞ÜÊ≠£Á°ÆÁöÑÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Ê≠£Â∏∏ÂΩ¢ÂºèÔºå
         * ÈîôËØØÁöÑÁªßÁª≠‰øùÁïôÂ≠óÁ¨¶‰∏≤„ÄÇ
         * */
        return `'${key}'${required ? "" : "?"}: ${getType(
          schemaObject.properties && schemaObject.properties[key],
          namespace
        )}; `;
      })
      .join("")}}`;
  }
  return "any";
};

/**
 * @description Ëé∑ÂèñRefÂêçÁß∞
 * @param refObject ËäÇÁÇπÂØπË±°
 * @returns String
*/
function getRefName(refObject: any): string {
  if (typeof refObject !== "object" || !refObject.$ref) {
    return refObject;
  }
  const refPaths = refObject.$ref.split("/");
  return resolveTypeName(refPaths[refPaths.length - 1]) as string;
}

export { ServiceGenerator };
